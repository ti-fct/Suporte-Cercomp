# backend.py
import os
import subprocess
import shutil
import json
import requests
import zipfile
import winreg
import sys
import time
import ctypes

# --- Constantes de Configura√ß√£o ---
DIRETORIO_APP_DATA = r"C:\ProgramData\Suporte-Cercomp"
DIRETORIO_LOGS = os.path.join(DIRETORIO_APP_DATA, "logs")
ARQUIVO_CONFIG = os.path.join(DIRETORIO_APP_DATA, "config.json")
CAMINHO_SCRIPT_WIDGET = os.path.join(DIRETORIO_APP_DATA, "AvisoDesktop.pyw")
DIRETORIO_PYTHON_WIDGET = os.path.join(DIRETORIO_APP_DATA, "python_widget_env")
REGISTRO_WIDGET = r"Software\Microsoft\Windows\CurrentVersion\Run"
CHAVE_REGISTRO_WIDGET = "FCT_UFG_DesktopInfo"

# Conte√∫do do script do widget (sem altera√ß√µes)
CONTEUDO_SCRIPT_WIDGET = """
# Aviso Desktop
import sys
import socket
try:
    from PyQt6.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout, QGraphicsDropShadowEffect
    from PyQt6.QtCore import Qt, QEvent, QTimer
    from PyQt6.QtGui import QColor
except ImportError:
    sys.exit()

class WidgetInfo(QWidget):
    def __init__(self):
        super().__init__()
        self.configurar_interface()

    def configurar_interface(self):
        self.setWindowTitle("WidgetInfo")
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint |
            Qt.WindowType.WindowStaysOnBottomHint |
            Qt.WindowType.Tool
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.rotulo = QLabel(self)
        self.rotulo.setText(self.formatar_texto())
        self.rotulo.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop)
        self.rotulo.setStyleSheet("QLabel { color: white; font-size: 11pt; }")
        sombra = QGraphicsDropShadowEffect(self)
        sombra.setBlurRadius(5)
        sombra.setOffset(2, 2)
        sombra.setColor(QColor(0, 0, 0))
        self.rotulo.setGraphicsEffect(sombra)
        layout = QVBoxLayout(self)
        layout.addWidget(self.rotulo)
        layout.setContentsMargins(10, 10, 10, 10)
        self.setLayout(layout)
        self.adjustSize()
        self.posicionar_widget()

    def formatar_texto(self):
        nome_computador = socket.gethostname()
        texto = (
            "<p style='margin:0; text-align:right; color:white;'>"
            "<b>üíª LAB. DE INFORM√ÅTICA - FCT/UFG</b><br>"
            "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>"
            f"{nome_computador}<br><br>"
            "<b>üìú REGRAS DE USO</b><br>"
            "üéì Uso exclusivo para atividades acad√™micas<br>"
            "üö´ N√£o consumir alimentos no laborat√≥rio<br>"
            "‚öôÔ∏è N√£o alterar configura√ß√µes do sistema<br><br>"
            "<b>üö™ PROCEDIMENTOS AO SAIR</b><br>"
            "üíæ Remova dispositivos externos<br>"
            "‚ùå Encerre todos os aplicativos<br>"
            "üîí Fa√ßa logout das contas<br><br>"
            "<b>üõ†Ô∏è SUPORTE T√âCNICO</b><br>"
            "üåê chamado.ufg.br<br>"
            "üí¨ (62) 3209-6555"
            "</p>"
        )
        return texto

    def posicionar_widget(self):
        tela = QApplication.primaryScreen()
        if tela:
            retangulo_disponivel = tela.availableGeometry()
            margem = 20
            x = retangulo_disponivel.right() - self.width() - margem
            y = retangulo_disponivel.top() + margem
            self.move(x, y)

    def changeEvent(self, evento):
        if evento.type() == QEvent.Type.WindowStateChange:
            if self.windowState() & Qt.WindowState.WindowMinimized:
                QTimer.singleShot(0, self.showNormal)
        super().changeEvent(evento)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    widget = WidgetInfo()
    widget.show()
    sys.exit(app.exec())
"""

# --- Fun√ß√µes L√≥gicas ---

def executar_comando_powershell(comando, timeout=180):
    """Executa um comando PowerShell."""
    yield f"Executando via PowerShell: {comando[:70]}..."
    try:
        processo = subprocess.run(
            ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", comando],
            capture_output=True, text=True, encoding='utf-8', errors='ignore',
            timeout=timeout, check=False
        )
        if processo.stdout:
            yield processo.stdout.strip()
        if processo.returncode != 0:
            yield f"ERRO: C√≥digo de retorno {processo.returncode}."
            if processo.stderr:
                yield f"Detalhes: {processo.stderr.strip()}"
    except Exception as e:
        yield f"ERRO CR√çTICO (PowerShell): {e}"

def executar_comando_cmd(comando, timeout=180, work_dir=None):
    """Executa um comando no CMD, com op√ß√£o de diret√≥rio de trabalho."""
    yield f"Executando via CMD: {comando[:70]}..."
    try:
        processo = subprocess.run(
            ["cmd", "/c", comando],
            capture_output=True, text=True, encoding='oem', errors='ignore',
            timeout=timeout, check=False, cwd=work_dir,
            creationflags=subprocess.CREATE_NO_WINDOW
        )
        if processo.stdout:
            yield processo.stdout.strip()
        if processo.returncode != 0:
            yield f"AVISO: C√≥digo de retorno {processo.returncode}."
            if processo.stderr:
                yield f"Sa√≠da de erro: {processo.stderr.strip()}"
    except Exception as e:
        yield f"ERRO CR√çTICO (CMD): {e}"

def baixar_recursos_necessarios(url_repositorio):
    """Baixa os arquivos de configura√ß√£o (GPOs, Tema) do GitHub."""
    arquivos_para_baixar = ["lgpo.exe", "machine.txt", "user.txt", "fct-labs.deskthemepack"]
    yield "Verificando e baixando recursos necess√°rios..."
    if not url_repositorio.endswith('/'):
        url_repositorio += '/'
    for arquivo in arquivos_para_baixar:
        url_arquivo = url_repositorio + arquivo
        caminho_destino = os.path.join(DIRETORIO_APP_DATA, arquivo)
        yield f"Baixando '{arquivo}'..."
        try:
            with requests.get(url_arquivo, stream=True, timeout=60) as r:
                r.raise_for_status()
                with open(caminho_destino, 'wb') as f:
                    shutil.copyfileobj(r.raw, f)
            yield f"'{arquivo}' baixado com sucesso."
        except requests.exceptions.RequestException as e:
            yield f"ERRO CR√çTICO ao baixar '{arquivo}': {e}"
            return
    yield "Download de todos os recursos conclu√≠do."

def gerenciar_widget_desktop(acao, config):
    """Adiciona ou remove o widget de aviso do desktop."""
    pythonw_exe = os.path.join(DIRETORIO_PYTHON_WIDGET, 'pythonw.exe')
    comando_finalizar = f'taskkill /F /IM pythonw.exe /FI "WINDOWTITLE eq WidgetInfo*"'

    if acao == 'adicionar':
        url_python_widget = config.get("URL_PYTHON_WIDGET")
        if not url_python_widget:
            yield "ERRO CR√çTICO: URL para o ambiente Python do widget n√£o configurada."
            return
        zip_path = os.path.join(DIRETORIO_APP_DATA, "python_widget_env.zip")
        yield f"Baixando ambiente Python do widget..."
        try:
            with requests.get(url_python_widget, stream=True, timeout=300) as r:
                r.raise_for_status()
                with open(zip_path, 'wb') as f: shutil.copyfileobj(r.raw, f)
        except requests.exceptions.RequestException as e:
            yield f"ERRO CR√çTICO ao baixar o ambiente do widget: {e}"; return
        yield "Extraindo ambiente Python..."
        try:
            if os.path.exists(DIRETORIO_PYTHON_WIDGET): shutil.rmtree(DIRETORIO_PYTHON_WIDGET)
            with zipfile.ZipFile(zip_path, 'r') as zip_ref: zip_ref.extractall(DIRETORIO_PYTHON_WIDGET)
            os.remove(zip_path)
        except Exception as e:
            yield f"ERRO CR√çTICO ao extrair o ambiente do widget: {e}"; return
        if not os.path.exists(pythonw_exe):
            yield f"ERRO CR√çTICO: 'pythonw.exe' n√£o encontrado ap√≥s extra√ß√£o."; return
        yield "Ambiente do widget instalado."
        yield f"Criando script do widget..."
        with open(CAMINHO_SCRIPT_WIDGET, "w", encoding="utf-8") as f: f.write(CONTEUDO_SCRIPT_WIDGET)
        yield "Adicionando √† inicializa√ß√£o do Windows..."
        try:
            comando_reg = f'"{pythonw_exe}" "{CAMINHO_SCRIPT_WIDGET}"'
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REGISTRO_WIDGET, 0, winreg.KEY_SET_VALUE) as key:
                winreg.SetValueEx(key, CHAVE_REGISTRO_WIDGET, 0, winreg.REG_SZ, comando_reg)
            yield "Widget configurado para iniciar com o Windows."
        except Exception as e:
            yield f"ERRO ao registrar na inicializa√ß√£o: {e}"; return
        yield "Finalizando inst√¢ncias antigas e iniciando o widget..."
        subprocess.run(comando_finalizar, shell=True, capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
        subprocess.Popen([pythonw_exe, CAMINHO_SCRIPT_WIDGET], creationflags=subprocess.CREATE_NO_WINDOW)
        yield "Widget adicionado e iniciado com sucesso."
    elif acao == 'remover':
        yield "Finalizando processo do widget..."
        subprocess.run(comando_finalizar, shell=True, capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
        yield "Removendo da inicializa√ß√£o do Windows..."
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, REGISTRO_WIDGET, 0, winreg.KEY_SET_VALUE) as key:
                winreg.DeleteValue(key, CHAVE_REGISTRO_WIDGET)
            yield "Registro de inicializa√ß√£o removido."
        except FileNotFoundError: yield "AVISO: Registro de inicializa√ß√£o n√£o encontrado."
        except Exception as e: yield f"ERRO ao remover do registro: {e}"
        if os.path.exists(CAMINHO_SCRIPT_WIDGET):
            try: os.remove(CAMINHO_SCRIPT_WIDGET); yield "Arquivo de script removido."
            except OSError as e: yield f"ERRO ao remover arquivo de script: {e}"
        if os.path.exists(DIRETORIO_PYTHON_WIDGET):
            try: shutil.rmtree(DIRETORIO_PYTHON_WIDGET); yield "Ambiente Python do widget removido."
            except OSError as e: yield f"ERRO ao remover diret√≥rio do widget: {e}"
        yield "Widget removido com sucesso."

def aplicar_tema_fct(caminho_tema):
    """
    Vers√£o alternativa que aplica o tema usando m√∫ltiplas estrat√©gias
    para detectar o usu√°rio logado.
    """
    yield "Iniciando aplica√ß√£o de tema (m√©todo alternativo)..."

    # Verificar privil√©gios de Administrador
    try:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin()
        if not is_admin:
            yield "ERRO CR√çTICO: Esta fun√ß√£o requer privil√©gios de Administrador."
            return
        yield "Verifica√ß√£o de privil√©gios de Administrador: OK."
    except Exception as e:
        yield f"ERRO ao verificar privil√©gios de Administrador: {e}"
        return

    # Valida√ß√£o do arquivo de tema
    if not os.path.exists(caminho_tema):
        yield f"ERRO: Arquivo de tema n√£o encontrado: {caminho_tema}."
        return
    yield f"Arquivo de tema encontrado: {os.path.basename(caminho_tema)}"

    # M√∫ltiplas estrat√©gias para obter usu√°rio logado
    usuario_logado = None
    
    # Estrat√©gia 1: Win32_ComputerSystem
    try:
        yield "Tentativa 1: Obtendo usu√°rio via Win32_ComputerSystem..."
        comando_ps1 = "(Get-CimInstance -ClassName Win32_ComputerSystem).Username"
        processo1 = subprocess.run(
            ["powershell", "-NoProfile", "-Command", comando_ps1],
            capture_output=True, text=True, encoding='utf-8',
            creationflags=subprocess.CREATE_NO_WINDOW, timeout=30
        )
        if processo1.stdout and processo1.stdout.strip():
            usuario_logado = processo1.stdout.strip()
            yield f"‚úì Usu√°rio encontrado (M√©todo 1): {usuario_logado}"
    except Exception as e:
        yield f"M√©todo 1 falhou: {e}"

    # Estrat√©gia 2: query user
    if not usuario_logado:
        try:
            yield "Tentativa 2: Obtendo usu√°rio via 'query user'..."
            processo2 = subprocess.run(
                ["query", "user"],
                capture_output=True, text=True, encoding='oem',
                creationflags=subprocess.CREATE_NO_WINDOW, timeout=30
            )
            if processo2.stdout:
                linhas = processo2.stdout.strip().split('\n')
                for linha in linhas[1:]:  # Pular cabe√ßalho
                    if 'Active' in linha or 'Ativo' in linha:
                        partes = linha.split()
                        if len(partes) > 0:
                            usuario_logado = partes[0]
                            yield f"‚úì Usu√°rio encontrado (M√©todo 2): {usuario_logado}"
                            break
        except Exception as e:
            yield f"M√©todo 2 falhou: {e}"

    # Estrat√©gia 3: whoami
    if not usuario_logado:
        try:
            yield "Tentativa 3: Obtendo usu√°rio via 'whoami'..."
            processo3 = subprocess.run(
                ["whoami"],
                capture_output=True, text=True, encoding='oem',
                creationflags=subprocess.CREATE_NO_WINDOW, timeout=30
            )
            if processo3.stdout and processo3.stdout.strip():
                whoami_result = processo3.stdout.strip()
                if '\\' in whoami_result:
                    usuario_logado = whoami_result.split('\\')[-1]
                    yield f"‚úì Usu√°rio encontrado (M√©todo 3): {usuario_logado}"
        except Exception as e:
            yield f"M√©todo 3 falhou: {e}"

    # Estrat√©gia 4: Vari√°vel de ambiente
    if not usuario_logado:
        try:
            yield "Tentativa 4: Obtendo usu√°rio via vari√°vel de ambiente..."
            usuario_env = os.environ.get('USERNAME')
            if usuario_env:
                usuario_logado = usuario_env
                yield f"‚úì Usu√°rio encontrado (M√©todo 4): {usuario_logado}"
        except Exception as e:
            yield f"M√©todo 4 falhou: {e}"

    # Verificar se encontrou usu√°rio
    if not usuario_logado:
        yield "AVISO: N√£o foi poss√≠vel determinar o usu√°rio logado."
        yield "Tentando aplicar tema sem contexto espec√≠fico de usu√°rio..."
        
        # Aplicar tema sem usu√°rio espec√≠fico
        try:
            yield "Aplicando tema diretamente..."
            subprocess.Popen([caminho_tema], shell=True)
            yield "Tema aplicado! A janela de personaliza√ß√£o deve abrir."
            return
        except Exception as e:
            yield f"ERRO ao aplicar tema: {e}"
            return

    # Aplicar tema com usu√°rio espec√≠fico
    yield f"Aplicando tema para o usu√°rio: {usuario_logado}..."
    
    # Script PowerShell mais robusto
    script_aplicar = f"""
    try {{
        # M√∫ltiplas tentativas de aplica√ß√£o
        $CaminhoTema = '{caminho_tema.replace("'", "''")}'

        Write-Output "Aguardando 5 segundos antes de aplicar..."
        Start-Sleep -Seconds 5
        
        # M√©todo 1: Start-Process simples
        try {{
            $ProcessInfo = Start-Process -FilePath 'explorer.exe' -ArgumentList "`"$CaminhoTema`"" -PassThru -ErrorAction Stop
            Write-Output "‚úì Tema aplicado via Start-Process. PID: $($ProcessInfo.Id)"
        }} catch {{
            Write-Warning "Start-Process falhou: $($_.Exception.Message)"
            
            # M√©todo 2: Invoke-Item
            try {{
                Invoke-Item -Path $CaminhoTema -ErrorAction Stop
                Write-Output "‚úì Tema aplicado via Invoke-Item"
            }} catch {{
                Write-Warning "Invoke-Item falhou: $($_.Exception.Message)"
                
                # M√©todo 3: cmd /c start
                try {{
                    cmd /c start `"Aplicar Tema`" `"$CaminhoTema`"
                    Write-Output "‚úì Tema aplicado via cmd start"
                }} catch {{
                    Write-Error "Todos os m√©todos falharam: $($_.Exception.Message)"
                    exit 1
                }}
            }}
        }}

        Write-Output "Aguardando 7 segundos para o sistema processar o tema..."
        Start-Sleep -Seconds 7

    }} catch {{
        Write-Error "ERRO CR√çTICO ao aplicar tema: $($_.Exception.Message)"
        exit 1
    }}
    """
    
    resultado = list(executar_comando_powershell(script_aplicar))
    for linha in resultado:
        yield linha

    yield "Aplica√ß√£o de tema conclu√≠da."
    yield "Se a janela 'Personaliza√ß√£o' abrir, pode fech√°-la."

def aplicar_gpos_fct(caminho_base_gpo):
    """Aplica as pol√≠ticas de grupo (GPOs) da FCT usando lgpo.exe."""
    arquivos_necessarios = [
        os.path.join(caminho_base_gpo, "lgpo.exe"),
        os.path.join(caminho_base_gpo, "machine.txt"),
        os.path.join(caminho_base_gpo, "user.txt")
    ]
    yield "Verificando arquivos de GPO necess√°rios..."
    if not all(os.path.exists(p) for p in arquivos_necessarios):
        yield f"ERRO: Arquivos de GPO n√£o encontrados em {caminho_base_gpo}."
        return
    
    diretorio_original = os.getcwd()
    try:
        os.chdir(caminho_base_gpo)
        yield "Aplicando pol√≠tica de m√°quina..."
        yield from executar_comando_cmd(r"lgpo.exe /t machine.txt")
        yield "Aplicando pol√≠tica de usu√°rio..."
        yield from executar_comando_cmd(r"lgpo.exe /t user.txt")
        yield "Comandos de aplica√ß√£o de GPOs da FCT enviados."
    except Exception as e:
        yield f"ERRO ao executar aplica√ß√£o de GPO: {e}"
    finally:
        os.chdir(diretorio_original)

# CORRIGIDO: BleachBit agora √© salvo em ProgramData
def iniciar_limpeza_sistema(url_ferramenta):
    """Baixa e executa o BleachBit para limpeza geral do sistema."""
    # O diret√≥rio base agora √© o mesmo da aplica√ß√£o
    base_dir = DIRETORIO_APP_DATA
    tool_dir = os.path.join(base_dir, "BleachBit")
    zip_path = os.path.join(base_dir, "BleachBit.zip")
    try:
        yield f"Baixando BleachBit para {base_dir}..."
        with requests.get(url_ferramenta, stream=True) as r:
            r.raise_for_status()
            with open(zip_path, 'wb') as f: shutil.copyfileobj(r.raw, f)
        yield f"Extraindo para {tool_dir}..."
        if os.path.exists(tool_dir): shutil.rmtree(tool_dir)
        with zipfile.ZipFile(zip_path, 'r') as zip_ref: zip_ref.extractall(tool_dir)
        yield "Procurando por bleachbit_console.exe..."
        caminho_executavel = next((os.path.join(r, f) for r, _, fs in os.walk(tool_dir) for f in fs if f == "bleachbit_console.exe"), None)
        if not caminho_executavel:
            yield "ERRO: bleachbit_console.exe n√£o encontrado ap√≥s a extra√ß√£o."; return
        yield f"Execut√°vel encontrado: {caminho_executavel}"
        yield "Listando limpadores dispon√≠veis..."
        list_process = subprocess.run([caminho_executavel, "--list-cleaners"], capture_output=True, text=True, check=True)
        all_cleaners = list_process.stdout.split()
        cleaners_to_run = [c for c in all_cleaners if not c.startswith("deep_scan.") and c != "system.free_disk_space"]
        yield f"{len(cleaners_to_run)} limpadores selecionados. AVISO: A limpeza pode demorar."
        yield "Executando limpeza com BleachBit..."
        subprocess.run([caminho_executavel, "--clean"] + cleaners_to_run, check=True, creationflags=subprocess.CREATE_NO_WINDOW)
        yield "Limpeza completa conclu√≠da!"
    except Exception as e:
        yield f"ERRO durante a limpeza: {e}"
    finally:
        # A limpeza dos arquivos baixados continua sendo uma boa pr√°tica
        if os.path.exists(tool_dir): shutil.rmtree(tool_dir, ignore_errors=True)
        if os.path.exists(zip_path): os.remove(zip_path)

def renomear_computador(novo_nome):
    """Altera o nome do computador no sistema."""
    yield f"Tentando alterar o nome para '{novo_nome}'..."
    yield from executar_comando_powershell(f'Rename-Computer -NewName "{novo_nome}" -Force -ErrorAction Stop')
    yield "Nome alterado! √â necess√°rio reiniciar para aplicar."

def restaurar_gpos_padrao():
    """Remove as pol√≠ticas locais e for√ßa a atualiza√ß√£o."""
    caminhos_gpo = [
        os.path.join(os.environ['WINDIR'], 'System32', 'GroupPolicy'),
        os.path.join(os.environ['WINDIR'], 'System32', 'GroupPolicyUsers')
    ]
    for path in caminhos_gpo:
        if os.path.exists(path):
            try:
                shutil.rmtree(path)
                yield f"Removido: {path}"
            except Exception as e:
                yield f"ERRO ao remover {path}: {e}"
    yield from executar_comando_cmd("gpupdate /force", timeout=120)
    yield "Restaura√ß√£o das GPOs padr√£o conclu√≠da."

def resetar_microsoft_store():
    """Limpa o cache e re-registra a Microsoft Store."""
    yield "Iniciando reset da Microsoft Store..."
    yield from executar_comando_cmd("wsreset.exe -q", timeout=120)
    yield "Comando de limpeza de cache enviado."
    yield "Re-registrando o aplicativo da Store..."
    comando = 'Get-AppxPackage *WindowsStore* -AllUsers | ForEach-Object {Add-AppxPackage -DisableDevelopmentMode -Register "$($_.InstallLocation)\\AppXManifest.xml"}'
    yield from executar_comando_powershell(comando)
    yield "Comando de re-registro enviado."

def forcar_atualizacao_gpos():
    """For√ßa a atualiza√ß√£o das Pol√≠ticas de Grupo (gpupdate)."""
    yield "For√ßando atualiza√ß√£o das Pol√≠ticas de Grupo (GPOs)..."
    yield from executar_comando_cmd("gpupdate /force", timeout=120)
    yield "Tentativa de atualiza√ß√£o de GPO conclu√≠da."

# CORRIGIDO: Usa um arquivo tempor√°rio para obter o nome de usu√°rio com acentos.
def limpar_pastas_usuario():
    """Limpa as pastas Desktop e Downloads do usu√°rio, lidando com acentos."""
    yield "Iniciando limpeza de pastas do usu√°rio..."
    temp_file = os.path.join(os.environ['TEMP'], 'current_user.tmp')
    # Comando PowerShell para salvar o nome de usu√°rio em um arquivo com codifica√ß√£o UTF-8
    comando_ps = f"(Get-CimInstance -ClassName Win32_ComputerSystem).Username | Out-File -FilePath '{temp_file}' -Encoding utf8 -NoNewline"
    
    try:
        # Executa o comando para criar o arquivo
        subprocess.run(
            ["powershell", "-NoProfile", "-Command", comando_ps],
            check=True, capture_output=True
        )

        # L√™ o nome do usu√°rio do arquivo com a codifica√ß√£o correta
        if not os.path.exists(temp_file):
            yield "ERRO: Arquivo tempor√°rio de usu√°rio n√£o foi criado."
            return
            
        with open(temp_file, 'r', encoding='utf-8') as f:
            nome_usuario_completo = f.read().strip()

        if not nome_usuario_completo:
            yield "ERRO: N√£o foi poss√≠vel determinar o usu√°rio logado."
            return
        
        nome_usuario = nome_usuario_completo.split('\\')[-1]
        yield f"Usu√°rio ativo encontrado: {nome_usuario}"

        caminho_base_usuario = os.path.join("C:\\Users", nome_usuario)
        pastas_para_limpar = {
            "Desktop": os.path.join(caminho_base_usuario, "Desktop"),
            "Downloads": os.path.join(caminho_base_usuario, "Downloads")
        }
        itens_a_preservar = ('.lnk', '.url', '.ini')

        for nome_pasta, caminho_pasta in pastas_para_limpar.items():
            yield f"--- Limpando a pasta {nome_pasta} ---"
            if not os.path.exists(caminho_pasta):
                yield f"AVISO: Pasta n√£o encontrada: {caminho_pasta}"
                continue
            for item in os.listdir(caminho_pasta):
                caminho_completo = os.path.join(caminho_pasta, item)
                if nome_pasta == "Desktop" and item.lower().endswith(itens_a_preservar):
                    yield f"Preservando: {item}"
                    continue
                try:
                    if os.path.isfile(caminho_completo) or os.path.islink(caminho_completo):
                        os.unlink(caminho_completo)
                    elif os.path.isdir(caminho_completo):
                        shutil.rmtree(caminho_completo)
                    yield f"Item removido: {item}"
                except Exception as e:
                    yield f"ERRO ao remover '{item}': {e}"
            yield f"Limpeza da pasta {nome_pasta} conclu√≠da."

    except subprocess.CalledProcessError as e:
        yield f"ERRO CR√çTICO ao obter nome do usu√°rio: {e}"
        if e.stderr:
            yield f"Detalhes do erro do PowerShell: {e.stderr.decode('utf-8', 'ignore')}"
    except Exception as e:
        yield f"ERRO CR√çTICO ao limpar pastas do usu√°rio: {e}"
    finally:
        # Garante que o arquivo tempor√°rio seja sempre removido
        if os.path.exists(temp_file):
            os.remove(temp_file)

def manutencao_preventiva_1_click(config):
    """Executa uma sequ√™ncia de tarefas de manuten√ß√£o preventiva."""
    yield "--- INICIANDO MANUTEN√á√ÉO PREVENTIVA COMPLETA ---"
    yield "\nPASSO 1/9: Baixando recursos da FCT..."
    yield from baixar_recursos_necessarios(config['URL_REPOSITORIO_FCT'])
    yield "\nPASSO 2/9: Restaurando GPOs Padr√£o..."
    yield from restaurar_gpos_padrao()
    yield "\nPASSO 3/9: For√ßando Atualiza√ß√£o de GPOs..."
    yield from forcar_atualizacao_gpos()
    yield "\nPASSO 4/9: Limpeza Geral do Sistema..."
    yield from iniciar_limpeza_sistema(config['URL_BLEACHBIT'])
    yield "\nPASSO 5/9: Limpando pastas do Usu√°rio..."
    yield from limpar_pastas_usuario()
    yield "\nPASSO 6/9: Aplicando Tema Visual da FCT..."
    yield from aplicar_tema_fct(config['CAMINHO_TEMA'])
    yield "\nPASSO 7/9: Aplicando GPOs da FCT..."
    yield from aplicar_gpos_fct(config['CAMINHO_BASE_GPO'])
    yield "\nPASSO 8/9: For√ßando atualiza√ß√£o de GPO novamente..."
    yield from forcar_atualizacao_gpos()
    yield "\nPASSO 9/9: Resetando a Microsoft Store..."
    yield from resetar_microsoft_store()
    yield "\n--- MANUTEN√á√ÉO PREVENTIVA CONCLU√çDA ---"
    yield "√â recomendado reiniciar o computador para que todas as altera√ß√µes tenham efeito."